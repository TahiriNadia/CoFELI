// Signature du document
:sigle: TMR_02
:titre: Mod√©lisation, conception et exploitation de donn√©es
:sous_titre: Th√©orie relationnelle
:organisation: CoFELI
:entrepot: CoFELI
:depot: Scriptorum
:branche: v100
:keywords: bases de donn√©es, th√©orie relationnelle, mod√®les relationnels
:revnumber: 0.1.4.c
:revdate: 2024-04-05
:version-label: document de travail, ne pas citer
:author: Christina KHNAISSER
:email: christina.khnaisser@usherbrooke.ca
:author2: Luc LAVOIE
:email2: luc.lavoie@usherbrooke.ca

// Contexte de support du document
include::../../../../rep_CoLOED_AsciiDoc.adoc[]
:rep_Scriptorum: {rep_racine}/CoFELI/Scriptorum

// Document bimodal PDF (texte, diaporama) et HTML5 (hypertexte).
// Les attributs format_DIAPO, format_TEXTE et format_HYPER
// permettent de particulariser le document au besoin.

ifndef::format_effectif[:format_effectif: RAPPORT]
ifdef::format_DIAPO[include::{rep_format}/DIAPO_en-tete.adoc[]]
ifndef::format_DIAPO[include::{rep_format}/{format_effectif}_en-tete.adoc[]]

ifndef::format_DIAPO[]
<<<
include::{rep_format}/SOMMAIRE.adoc[]
Le pr√©sent module a √©t√© r√©dig√© dans le cadre de l‚Äôexploration du th√®me
¬´‚ÄØMod√©lisation, conception et exploitation de donn√©es‚ÄØ¬ª (MCED)
par des membres du CoFELI.
Le module pr√©sente l‚Äôessentiel de la th√©orie relationnelle et en fixe la notation
pour les autres modules du th√®me.
Il d√©coule en partie des travaux entrepris au sein des groupes de recherche ŒúŒ∑œÑŒπœÇ et GRIIS.
Il correspond √† des connaissances usuellement couvertes au sein du B. Sc. nord-am√©ricain,
de la licence ou du mast√®re europ√©en et de certaines √©coles d‚Äôing√©nieur.
Ce module est destin√© aux personnes √©tudiant les disciplines de l‚Äôinformatique,
de l‚Äôinformatique appliqu√©e et du g√©nie logiciel.
Nous esp√©rons toutefois qu‚Äôil pourra √™tre utile √† toute personne curieuse
d‚Äôapprivoiser ce champ de connaissance.

include::{rep_format}/MISE_EN_GARDE.adoc[]
Le pr√©sent document est en cours d‚Äô√©laboration ;
en cons√©quence, il est incomplet et peut contenir des erreurs.

include::{rep_format}/HISTO_debut.adoc[]

| 2023-10-01
| LL
| Adaptation au cadre du CoFELI.

| 2023-09-07
| LL
| Int√©gration au CoFELI et encodage √† l‚Äôaide d‚ÄôAsciidoc.

| 2023-09-06
| LL
| Ajout des crit√®res de r√©futabilit√© et d‚Äô√©thique. Correction de coquilles.

| 2023-01-11
| LL
| Corrections stylistiques.

| 2023-01-10
| LL
| Corrections stylistiques - pr√©sentation des op√©rateurs d‚Äôagr√©gation.

| 2022-01-10
| LL
| Ajout de la base et de son constructeur.

| 2021-10-24
| LL
| Harmonisation avec la pr√©sentation BD010 pr√©par√©e pour Douala.

| 2021-03-19
| LL
| Introduction des d√©nominations ¬´‚ÄØtype primitif‚ÄØ¬ª et ¬´‚ÄØsous-type‚ÄØ¬ª‚ÄØ;
  distinction de l‚Äôunion disjointe et de la r√©union (ou somme) disjointe.

| 2021-01-26
| LL
| Syst√©matisation de la pr√©sentation, correction de coquilles, √©claircissements divers,
  introduction des traductions SQL des op√©rateurs de base.

| 2020-09-20
| LL
| D√©but de pr√©sentation de la notation relative aux couples et aux ensembles

| 2019-07-25
| LL
| Correction des coquilles signal√©es par Maxime Routhier.

| 2019-06-23
| LL
| Correction de coquilles.

| 2019-05-01
| LL
| R√©cup√©ration de notes diverses.

include::{rep_format}/HISTO_fin.adoc[]

endif::format_DIAPO[]

<<<
toc::[]

// Corps du document
<<<
[introduction]
== Introduction

// Objet et port√©e du document
Le pr√©sent document a pour but de pr√©senter une synth√®se de la th√©orie relationnelle
propos√©e par Edgar F. Codd et d√©velopp√©e par la suite avec les contributions,
notamment, de Christopher J. Date, Raymond F. Boyce, Nikos A. Lorentzos et Jeffrey D. Ullman.

La pr√©sentation repose sur des bases minimales‚ÄØ:

* la logique du premier ordre,
* la th√©orie des ensembles,
* l‚Äôarithm√©tique,
* les langages rationnels.

// L‚Äôinclusion suivante apour but de forcer le chargement des polices dans le
// contexte des diaporamas (en raison d‚Äôune erreur dans le logiciel asciidoctor).
// Est-elle encore requise ?
ifdef::format_DIAPO[* un s√©jour chez ŒúŒ∑œÑŒπœÇ üòÄ]

ifndef::format_DIAPO[]
.√âvolution du document
Le pr√©sent document tire son origine de l‚Äôexp√©rience d‚Äôenseignement des auteurs.
Cette pr√©sentation n‚Äôa cess√© d‚Äô√©voluer depuis gr√¢ce aux √©tudiants et auxiliaires
d‚Äôenseignement qui ont particip√© aux cours depuis.
La r√©daction du document a commenc√© en aout 2012.
La premi√®re version du document a √©t√© √©tablie sur les bases suivantes‚ÄØ:

* le mat√©riel p√©dagogique d√©velopp√© par l‚Äôauteur dans le cadre de formations relatives
  aux bases de donn√©es assur√©es entre 1983 et 2022 au Qu√©bec, en France, en Tunisie,
  en Suisse, au Maroc, au Liban et au Cameroun‚ÄØ;
* des √©changes avec de nombreux √©tudiants et collaborateurs, plus particuli√®rement
  Zouhir Abouddaoui, Samuel Dussault, Marc Frappier, Aur√©lie Ottavi et Maxime Routhier‚ÄØ;
* les diff√©rents travaux publi√©s par Codd, Darwen, Date, Delobel, Elmasri, Lorentzos,
  Navathe, Snodgrass et Ullman.

.Travail en cours ou projet√©
* R√©diger la section 2 √† partir des pr√©sentations BD010 et TMR_01 d√©velopp√©s √†
  l‚ÄôUniversit√© de Sherbrooke.
* Compl√©ter la partie des op√©rateurs relatifs aux intervalles de la section 3.
* Compl√©ter les exemples et exercices de la section 3.
* R√©diger les sections 4, 5 et 6.
* Ajouter une section portant sp√©cifiquement sur les noyaux de l‚Äôalg√®bre relationnelle.
* Faire les tableaux d‚Äô√©quivalence Discipulus ‚Äì TD ‚Äì SQL.

.Contenu des sections
* La section 2 pr√©sente l‚Äôessence de la th√©orie relationnelle et le mod√®le qui
  sera utilis√© tout au long de la pr√©sentation.
* La section 3 pr√©sente les op√©rateurs relationnels tant √©l√©mentaires que d√©riv√©s
  et composites.
* La section 4 explicite le lien entre la th√©orie relationnelle et la logique du premier ordre
  en d√©veloppant les correspondances entre relation et pr√©dicat, tuple et proposition.
* La section 5 int√®gre le constructeur de type intervalle, les op√©rateurs de Allen
  et les op√©rateurs relationnels qui en tirent parti (tels que propos√©s par
  Darwen, Date et Lorentzos).
* La section 6 pr√©sente et compare un sous-ensemble minimal de trois langages de
  programmation relationnels.
endif::format_DIAPO[]

<<<
== Pr√©sentation
La logique et la d√©duction rationnelle sont les outils privil√©gi√©s par la science
pour encadrer notre perception du monde, le penser et l‚Äôexpliquer.
Thal√®s, Pythagore, Platon, Aristote, Archim√®de, Pappus, Descartes, Tarski,
Russell, Whitehead, Wittgenstein, G√∂del et Turing sont quelques-uns des penseurs
qui ont contribu√© √† d√©velopper notre compr√©hension de ces outils et √† d√©finir
ce que sont une th√©orie, un mod√®le et un syst√®me axiomatique.

Plus r√©cemment, Floyd, Codd, Hoare, Dijkstra, Gries, Date, Ullman et d‚Äôautres,
ont contribu√© √† rendre effectivement calculable un sous-ensemble significatif
des propri√©t√©s des syst√®mes construits sur les bases √©tablies par leurs pr√©d√©cesseurs.
ifdef::format_DIAPO[ ]
Ces contributions sont presque enti√®rement int√©gr√©es dans la th√©orie, les mod√®les
et les syst√®mes relationnels que nous d√©crirons ici et qui sont le fondement des syst√®mes
de gestion de bases de donn√©es (SGBD) les plus performants d√©velopp√©s √† ce jour,
√† savoir les SGBD relationnels (SGBDR).

ifdef::format_DIAPO[<<<]
=== L‚Äôintuition √† l‚Äôorigine de la th√©orie relationnelle

* Le point de d√©part‚ÄØ: un fait ‚â° une proposition ‚â° un tuple.
* Des op√©rations‚ÄØ: la logique aristot√©licienne bivalu√©e (dite logique classique).
* Une g√©n√©ralisation‚ÄØ: une cat√©gorie ‚â° un pr√©dicat ‚â° une relation.
* Des op√©rations‚ÄØ: la th√©orie des ensembles.
* Une limite source de puissance‚ÄØ: une vision encapsul√©e dans un monde ferm√©.
* L‚Äôinformatisation (automatisation du calcul).
* Von Neuman, la dualit√© donn√©e-calcul et son corolaire‚ÄØ:
  la relation est repr√©sentable tant par un ensemble de tuples (donn√©es) que
  par une expression (calcul).

ifndef::format_DIAPO[]
// √Ä mettre aussi dans les notes du pr√©sentateur‚Ä¶ un jour.
* Une intuition‚ÄØ: permettre les deux fa√ßons d‚Äôexprimer la relation et
  laisser l‚Äôengin choisir la repr√©sentation‚ÄØ; justification de la dualit√©
  relation ¬´‚ÄØmat√©rialis√©e‚ÄØ¬ª et relation ¬´‚ÄØvirtuelle‚ÄØ¬ª.
endif::format_DIAPO[]

* Coupler la th√©orie relationnelle √† la th√©orie des types.

ifndef::format_DIAPO[]
// √Ä mettre aussi dans les notes du pr√©sentateur‚Ä¶ un jour.
* Les outils‚ÄØ: le g√©n√©rateur de type de relation, le type de relation,
  la relation, la variable de relation et la fonction de relation.
endif::format_DIAPO[]

ifdef::format_DIAPO[<<<]
[TIP]
====
.Retour sur la mod√©lisation de la r√©alit√©
Qu‚Äôest-ce qui se cache derri√®re l‚Äôapproche tri-sch√©matique et ses niveaux‚ÄØ:

* conceptuel‚ÄØ: mod√®le d√©duit du probl√®me et pertinent √† l‚Äôexpression de la
  solution‚ÄØ;
* logique‚ÄØ: mod√®le inf√©r√© du pr√©c√©dent √† l‚Äôaide d‚Äôun m√©ta-mod√®le (relationnel)
  apte √† garantir l‚Äôint√©grit√© des donn√©es et des op√©rations qui leur sont
  appliqu√©es tout en permettant leur interpr√©tation sous la forme de propositions
  logiques‚ÄØ;
* physique‚ÄØ: organisation mat√©rielle des donn√©es sur un support physique de
  fa√ßon √† optimiser les performances des op√©rations‚ÄØ; id√©alement,
  cette organisation doit pouvoir √™tre inf√©r√©e du mod√®le logique.
====

ifdef::format_DIAPO[<<<]
=== Mod√©lisation logique ou conceptuelle ?
Traditionnellement, les applications sont construites sur la base du mod√®le logique.
ifdef::format_DIAPO[ ]
Certains pr√©f√®reraient les construire sur la base du mod√®le conceptuel.
ifdef::format_DIAPO[ ]
Il semble plut√¥t que le point de d√©part devrait √™tre le mod√®le de connaissances
permettant de d√©terminer directement le mod√®le logique‚ÄØ;
le mod√®le conceptuel √©tant plut√¥t un outil de communication utilis√© par
l‚Äôinformaticien pour vulgariser le mod√®le de connaissance aux fins de validation
du mod√®le logique.

ifdef::format_DIAPO[<<<]
=== Pourquoi le mod√®le relationnel ?
Pour sa capacit√© √† fonder formellement

* la description automatisable du calcul du raisonnement et
* plusieurs des crit√®res d‚Äôad√©quation d‚Äôune solution en regard d‚Äôau probl√®me.

ifdef::format_DIAPO[<<<]
.√âquivalence avec la logique du premier ordre
* n√©cessitant l‚Äô√©quivalence des ¬´‚ÄØfaits‚ÄØ¬ª (proposition, variable, pr√©dicat)‚ÄØ;
* n√©cessitant l‚Äô√©quivalence des op√©rateurs (relationnels et logiques)‚ÄØ;
* n√©cessitant l‚Äô√©galit√©‚ÄØ;
* utilisant la notion d‚Äôensemble‚ÄØ;
* utilisant des attributs d√©notationnels plut√¥t que positionnels‚ÄØ;
* soutenant une alg√®bre compl√®te au sens de Turing.

ifdef::format_DIAPO[<<<]
.Ad√©quation
* valide ‚Äì est conforme au mod√®le‚ÄØ;
* efficace ‚Äì est conforme aux attentes (besoins, exigences‚Ä¶)‚ÄØ;
* coh√©rent ‚Äì ne comporte pas de contradiction‚ÄØ;
* √©volutif ‚Äì peut ¬´‚ÄØais√©ment‚ÄØ¬ª √™tre adapt√© aux changements‚ÄØ;
* efficient ‚Äì utilise ¬´‚ÄØbien‚ÄØ¬ª les ressources‚ÄØ;
* complet ‚Äì offre une couverture ¬´‚ÄØsuffisante‚ÄØ¬ª du probl√®me‚ÄØ;
* r√©futable ‚Äì apte √† permettre la validation et, corolairement, l‚Äôinvalidation‚ÄØ;
* √©thique ‚Äì conforme aux principes et r√®gles de conduite d‚Äôune soci√©t√© humaine de r√©f√©rence.

ifdef::format_DIAPO[<<<]
== Structure relationnelle
La th√©orie relationnelle peut √™tre construite sur la seule base de la logique
du premier ordre et de la th√©orie des ensembles.
ifdef::format_DIAPO[ ]
En pratique, il faut aussi ajouter un mod√®le de typage.
ifdef::format_DIAPO[ ]
Finalement, il est √©galement utile d‚Äôy ajouter l‚Äôarithm√©tique et les langages rationnels
afin de rendre compte de certaines propri√©t√©s fondamentales et d‚Äôint√©grer
les nombres et les textes aux types primitifs.

ifdef::format_DIAPO[<<<]
=== Logique
Nous utiliserons les op√©rateurs suivants pour les expressions logiques
(adaptation libre de https://fr.wikipedia.org/wiki/Portail:Logique,
consult√© les 2021-10-24 et 2024-04-07)‚ÄØ:

ifdef::format_DIAPO[<<<]
[%unbreakable]
--
.Op√©rateurs de la logique du premier ordre
[%autowidth]
|===
|Symbole |Sp√©cification

| ¬¨ A   | N√©gation de A. Non A.
| A ‚àß B | Conjonction. A et B.
| A ‚à® B | Disjonction (inclusive). A ou B.
| A ‚áí B | Implication. Si A alors B.
| A ‚áî B | √âquivalence. A est √©quivalent √† B‚ÄØ; on dit aussi‚ÄØ: A si et seulement si B.
| Œì ‚ä¢ A | D√©duction. De l‚Äôensemble de formules Œì on d√©duit A.
| M ‚ä© A | R√©alisabilit√©. M r√©alise A, on dit aussi que M ¬´‚ÄØforce‚ÄØ¬ª A.
| M ‚ä® A | Mod√©lisation. M est un mod√®le de A‚ÄØ; on dit aussi A est vraie dans M.
| ‚ä¢ A   | Th√©or√®me. Notion syntaxique.
| ‚ä® A   | Tautologie. Notion s√©mantique.

|===
--

ifdef::format_DIAPO[<<<]
=== Ensemble
Dans le cadre de la th√©orie relationnelle, les √©l√©ments d‚Äôun ensemble sont toujours
contraints par un type associ√© √† l‚Äôensemble lui-m√™me ‚Äì ce type est d√©sign√© comme
le ¬´‚ÄØtype de r√©f√©rence‚ÄØ¬ª de l‚Äôensemble et not√©
[.Math]#typeref(e)# o√π [.Math]#e# est un ensemble.

Cette association peut √™tre explicite (par voie de d√©claration) ou d√©duite
gr√¢ce au contexte.

ifdef::avec_annotations[////]
////
[%hardbreaks.maroon]
TODO 2022-10-01 (LL01) : distinction g√©n√©rale entre valeur et d√©notation
  Il y a ici confusion entre le type de r√©f√©rence et l‚Äôensemble de r√©f√©rence.
  √Ä tout type est associ√© un ensemble de valeurs, le type lui-m√™me est une d√©notation
  d‚Äôun ensemble de valeurs. Bref, ne faudrait-il pas deux fonctions, l‚Äôune pour
  l‚Äôidentifiant du type et l‚Äôautre pour l‚Äôensemble de valeurs du type ?
  Je n‚Äôarrive pas √† r√©soudre la circularit√© entre ensemble et type.
    * Op√©rer le d√©tour suivant : ensemble, type, ensemble typ√© ?
    * Ou encore : type scalaire, type non scalaire, type structur√©
      (donc poss√©dant une structure ET donnant acc√®s √† celle-ci) ?
  Les types structur√©s minimaux de la TR (tuple, relation, base) utilisent
  un m√™me ¬´ m√©canisme d‚Äôacc√®s ¬ª, une liste d‚Äôidentifiants comprise dans la
  d√©finition du type (effectif).
  Certains pourraient utiliser un type ordinal (en bijection avec un intervalle
  d‚Äôentiers non n√©gatifs), comme le tableau. Etc.
ifdef::avec_annotations[////]
////

ifdef::format_DIAPO[<<<]
==== Cas g√©n√©ral

Les ensembles sont simples, ils ne poss√®dent qu‚Äôun constructeur et une propri√©t√©.
ifdef::format_DIAPO[ ]
Le nombre d‚Äôop√©rateurs est toutefois consid√©rables.
ifdef::format_DIAPO[ ]
Nous n‚Äôen pr√©senterons que quelques-uns.

ifdef::format_DIAPO[<<<]
.D√©notation des valeurs et propri√©t√©s
--
{}::
  l‚Äôensemble vide.
{ z }::
  l‚Äôensemble comprenant une seule valeur d√©not√©e par l‚Äôexpression z +
  (synonyme‚ÄØ: singleton).
{ z~1~, z~2~, ‚Ä¶,  z~n~ }::
  l‚Äôensemble comprenant les seules valeurs d√©not√©es par les expressions z~i~. +
  [.small]#Le point-virgule ¬´‚ÄØ;‚ÄØ¬ª peut √™tre utilis√© indiff√©remment en
  lieu et place de la virgule ¬´‚ÄØ,‚ÄØ¬ª.#
# e::
  la cardinalit√© de l‚Äôensemble e.
--

ifdef::format_DIAPO[<<<]
.Op√©rateurs usuels
--
a = b::
  √©galit√© de a et b.
a ‚â† b::
  in√©galit√© de a et b.
z ‚àà e::
  appartenance (d‚Äôun √©l√©ment z √† un ensemble e)
z ‚àâ e::
  non-appartenance (d‚Äôun √©l√©ment z √† un ensemble e)
e ‚àã z::
  appartenance (d‚Äôun √©l√©ment z √† un ensemble e)
e ‚àå z::
  non-appartenance (d‚Äôun √©l√©ment x √† un ensemble e)
e~1~ ‚äÇ e~2~::
  e~1~ est un sous-ensemble strict de e~2~
e~1~ ‚äÉ e~2~::
  e~2~ est un sous-ensemble strict de e~1~
e~1~ ‚äÑ e~2~::
  e~1~ n‚Äôest pas un sous-ensemble strict de e~2~
e~1~ ‚äÖ e~2~::
  e~2~ n‚Äôest pas un sous-ensemble strict de e~1~
e~1~ ‚äÜ e~2~::
  e~1~ est un sous-ensemble de e~2~
e~1~ ‚äá e~2~::
  e~2~ est un sous-ensemble de e~1~
e~1~ ‚àí e~2~::
  la diff√©rence de e~2~ moins e~1~
e~1~ ‚à™ e~2~::
  l‚Äôunion de e~1~ et e~2~
e~1~ ‚à© e~2~::
  l‚Äôintersection de e~1~ et e~2~
e~1~ √ó e~2~::
  le produit cart√©sien de e~2~
--

////
.Op√©rateurs moins usuels
* ‚©Å ‚®É ‚®Ñ ‚©Ç ‚©Ä ‚©É
////

ifdef::format_DIAPO[<<<]
.Raccourcis
Dans la mesure o√π tous les ensembles ont un type de r√©f√©rence, l‚Äôop√©rateur ¬´‚ÄØ\‚ÄØ¬ª
permet de calculer le compl√©ment d‚Äôun sous-ensemble par rapport √† son type de r√©f√©rence.

\ e ‚âú typeref(e) ‚Äì e::
  o√π [.Math]#e# est une expression dont la valeur est un ensemble typ√©.

_Note_‚ÄØ:
en Tutorial D, cet op√©rateur n‚Äôest utilisable que dans un contexte de
d√©notation explicite des valeurs, ainsi [.TutorialD]#{ALL BUT e~1~, ‚Ä¶, e~n~}#
d√©note [.Math]#\{ e~1~, ‚Ä¶, e~n~ }#.
ifdef::format_DIAPO[ ]
On aurait souhait√©, la syntaxe plus g√©n√©rale suivante [.TutorialD]#ALL BUT exp#,
o√π [.TutorialD]#exp# d√©note toute expression ensembliste typ√©e.
ifdef::format_DIAPO[ ]
En Discipulus, la syntaxe g√©n√©rale est utilis√©e et les expressions d‚Äôensemble
(en particulier d‚Äôensembles d‚Äôidentifiants d‚Äôattributs) sont d√©notables.

ifdef::format_DIAPO[<<<]
==== Couple
Le couple, aussi appel√© la paire, est la formation d‚Äôune nouvelle entit√© (ou √©l√©ment)
√† partir de deux autres.
ifdef::format_DIAPO[ ]
Il serait possible de reformuler le couple en termes d‚Äôensemble,
son utilisation au titre de construction propre rel√®ve donc uniquement de la commodit√©.

ifdef::format_DIAPO[<<<]
.D√©notation des valeurs et propri√©t√©s
--
(x‚ÄØ; y)::
  pour x et y des expressions d√©notant des valeurs appropri√©es.
--

_Note_‚ÄØ:
la virgule ¬´‚ÄØ,‚ÄØ¬ª est souvent utilis√©e en lieu et place du point-virgule ¬´‚ÄØ;‚ÄØ¬ª
lorsqu‚Äôelle n‚Äôentraine pas d‚Äôambig√ºit√© (e.a. en pr√©sence de nombres rationnels
repr√©sent√©s en notation fractionnaire d√©cimale).

ifdef::format_DIAPO[<<<]
.Op√©rateurs usuels
--
@1(x‚ÄØ; y) = x::
  l‚Äô√©l√©ment gauche du couple ;
@2(x‚ÄØ; y) = y::
  l‚Äô√©l√©ment droit du couple.
--

ifdef::format_DIAPO[<<<]
=== Type
Si la th√©orie relationnelle peut s‚Äôaccommoder de plusieurs mod√®les de typage,
certaines exigences doivent √™tre respect√©es.
ifdef::format_DIAPO[ ]
Malheureusement, il n‚Äôy a pas de consensus relativement √† ces exigences
(notamment, celles du comit√© ISO 9075 diff√®rent de celles √©nonc√©es par Codd et
d√©velopp√©es par Date et Darwen).
ifdef::format_DIAPO[ ]
Nous nous en tiendrons donc ici √† un mod√®le de typage tr√®s simple,
√©galement acceptable en regard des jeux d‚Äôexigences les plus courants.

Une donn√©e est une valeur associ√©e √† deux repr√©sentations
(l‚Äôune interne, apte √† √™tre trait√©e par ordinateur‚ÄØ;
l‚Äôautre externe, apte √† √™tre utilis√©e au sein d‚Äôun langage formel).

ifndef::format_DIAPO[]
[TIP]
====
Un langage formel apte √† √™tre trait√© ¬´‚ÄØcommod√©ment‚ÄØ¬ª par un ordinateur.
üòÄ
====
endif::format_DIAPO[]

ifdef::format_DIAPO[<<<]
Une repr√©sentation est une suite de signaux (un signal est un ph√©nom√®ne physique
mesurable, donc suffisamment stable pour √™tre mesur√©).

Dans le cadre de la th√©orie minimaliste de typage utilis√©e dans le pr√©sent document,
un type est soit un type de base, soit un sous-type.

Un type de base (appel√© aussi type racine ou domaine) est un ensemble fini de valeurs propres
(c‚Äôest-√†-dire que les valeurs d‚Äôun type de base n‚Äôappartiennent √† aucun autre type de base).
Une valeur est donc un √©l√©ment d‚Äôun type de base.

Un sous-type (appel√© aussi type d√©riv√©) est un sous-ensemble d‚Äôun type,
sous-ensemble d√©termin√© par une contrainte explicite
(qui restreint les valeurs accept√©es dans le sous-ensemble).

ifdef::format_DIAPO[<<<]
[TIP]
====
La finitude des types suscite encore de nombreux d√©bats.
ifdef::format_DIAPO[ ]
√Ä telle enseigne que Date lui-m√™me l‚Äôa retir√© de sa d√©finition depuis 2016,
moins par conviction selon nous, mais plut√¥t pour √©viter un d√©bat peu productif.
ifdef::format_DIAPO[ ]
N‚Äôayant pas sa notori√©t√© ni son influence, nous pouvons nous permettre de la maintenir,
et de l‚Äôutiliser, dans le pr√©sent document.
ifdef::format_DIAPO[ ]
S‚Äôil est vrai que la structure math√©matique,
et plus particuli√®rement alg√©brique du mod√®le relationnel, ne repose pas sur la finitude
des types, son application pratique, elle, repose sur cette hypoth√®se - du moins,
tant que nous ne b√©n√©ficierons pas de machine de calcul (ordinateur) dot√©e
d‚Äôune m√©moire infinie.
üòÄ
====

ifdef::format_DIAPO[<<<]
=== Attribut
Un attribut est un couple form√© d‚Äôun identifiant a et d‚Äôun type D, not√© a:D.
ifdef::format_DIAPO[ ]
Par abus de langage, lorsque le contexte le permet, il est usuel de d√©signer
l‚Äôattribut par son seul identifiant‚ÄØ; ainsi peut-on √©crire ¬´‚ÄØl‚Äôattribut a‚ÄØ¬ª.

[TIP]
====
C‚Äôest-√†-dire que le contexte permet de d√©terminer de fa√ßon univoque et non ambig√ºe
le type associ√© √† l‚Äôidentifiant au sein de l‚Äôattribut.
====

ifdef::format_DIAPO[<<<]
[NOTE]
====
La mise en page des expressions formelles des trois prochaines sous-sections
(tuple, relation, base) varie d‚Äôune sous-section √† l‚Äôautre. C‚Äôest volontaire.
Nous y exp√©rimentons trois m√©canismes diff√©rents mis √† disposition par AsciiDoc
pour ce faire.
ifdef::format_DIAPO[ ]
Nous d√©sirons recueillir ainsi les commentaires de nos lecteurs, afin de choisir
ce qui convient le mieux.
Malheureusement, le r√©sultat n‚Äôest pleinement appr√©ciable qu‚Äôau format PDF.
L‚Äôadaptation au format HTML5 ne sera r√©alis√©e que pour le type de mise en forme retenu.
====

ifdef::format_DIAPO[<<<]
=== Tuple
Un tuple, en tant qu‚Äôobjet de la th√©orie relationnelle, est une
¬´‚ÄØcomposition‚ÄØ¬ª d‚Äôattributs.
ifdef::format_DIAPO[ ]
En regard de la th√©orie des types, il s‚Äôagit d‚Äôun constructeur de type non scalaire
applicable √† un ensemble d‚Äôattributs.

[%unbreakable]
--
Soit [.Math]#n# un entier naturel, +
Soit [.Math]#n# identifiants *distincts* d√©not√©s [.Math]#a~i~ | 1 ‚â§ i ‚â§ n#, +
Soit [.Math]#n# types (pas n√©cessairement distincts) d√©not√©s [.Math]#D~i~ | 1 ‚â§ i ‚â§ n#, +
Soit [.Math]#n# valeurs (pas n√©cessairement distinctes) d√©not√©es [.Math]#v~i~ | 1 ‚â§ i ‚â§ n#, +

Si [.Math]#(1 ‚â§ i ‚â§ n) ‚áí (a~i~ ‚àà D~i~)#, alors
un tuple [.Math]#t# est d√©fini comme suit‚ÄØ:

[width=90%, grid=none, frame=none, role=center, halign=center, valign=middle]
|===
| [.Math]#t ‚âú ({a~i~:D~i~ \| 1 ‚â§ i ‚â§ n}; {(a~i~,v~i~) \| 1 ‚â§ i ‚â§ n})#
|===

ou, de fa√ßon √©quivalente, en extension :

[width=90%, grid=none, frame=none, role=center]
|===
| [.Math]#t ‚âú ({a~1~:D~1~, ‚Ä¶, a~i~:D~i~, ‚Ä¶ , a~n~:D~n~}; {(a~1~,v~1~), ‚Ä¶, (a~i~,v~i~), ‚Ä¶ (a~n~,v~n~)})#
|===
--

[%unbreakable]
--
Sont √©galement d√©finis

[width=90%, grid=none, frame=none, role=center]
|===
| [.Math]#deg(t) = n#                             | degr√© de t
| [.Math]#id(t) = {a~i~ \| 1 ‚â§ i ‚â§ n}#            | ensemble des identifiants d‚Äôattributs de t
| [.Math]#def(t) = {a~i~:D~i~ \| 1 ‚â§ i ‚â§ n}#      | ent√™te de t
| [.Math]#val(t) = {(a~i~,v~i~) \| 1 ‚â§ i ‚â§ n}#    | valeur de t
| [.Math]#ANTE a ‚àä id(t) : def(t, a) = D \| a:D ‚àä def(t)#    | type de l‚Äôattribut a~i~ de t
| [.Math]#ANTE a ‚àä id(t) : val(t, a) = v \| (a,v) ‚àä val(t)#  | valeur de l‚Äôattribut a~i~ de t
|===
--

ifdef::format_DIAPO[<<<]
.Observation
Pourquoi autoriser [.Math]#deg(t) = 0#‚ÄØ?

Le cas [.Math]#deg(t) = 0# correspond √† un tuple remarquable [.Math]#({}‚ÄØ; {})#
souvent d√©sign√© par l‚Äôidentifiant [.Math]#t~0~#.

.Exercice
Expliquer pourquoi ce tuple est remarquable‚Ä¶ et essentiel‚ÄØ!

ifdef::format_DIAPO[<<<]
.Autres d√©notations fr√©quentes
Parmi les plus fr√©quentes‚ÄØ:

* d√©notation des tuples fond√©e sur l‚Äôordre d‚Äô√©num√©ration des attributs
  (les identifiants d‚Äôattributs et leurs types √©tant d√©termin√©s par ailleurs)‚ÄØ:
  - [.Math]#<v~1~, v~2~,‚Ä¶ , v~n~>#
* d√©notation des attributs au sein d‚Äôun tuple, [.Math]#val(t, a)#‚ÄØ:
  - [.Math]#t.a#
  - [.Math]#a(t)#
  - [.Math]#t(a)#
  - [.Math]#a FROM t#

ifdef::format_DIAPO[<<<]
.D√©notation des constructeurs de types et de valeurs
Il est important, en pratique et du point de vue du g√©nie logiciel, de diff√©rencier
syntaxiquement le constructeur de types du constructeur de valeurs, ce que Tutorial D
ne fait pas de fa√ßon assez explicite, nous semble-t-il.

Deux solutions sont g√©n√©ralement utilis√©es,

* des mots-cl√©s diff√©rents, par exemple [.CodeS]#TUPLE# et [.CodeS]#TUP# ;
* un seul mot-cl√© ([.CodeS]#TUPLE#) mais des parenth√®ses diff√©rentes,
  par exemple [.CodeS]#{}# et [.CodeS]#[]#.

Discipulus a adopt√© cette derni√®re solution‚Ä¶ pour le moment.
Ainsi,

* le type tuple sans attribut est-il d√©not√© par [.CodeS]#TUPLE {}# ;
* et la (seule) valeur (possible) d‚Äôun tuple sans attribut
  par [.CodeS]#TUPLE [{} ; {}]#.

ifdef::format_DIAPO[<<<]
=== Relation
Une relation, en tant qu‚Äôobjet de la th√©orie relationnelle, est un ensemble de tuples.
ifdef::format_DIAPO[ ]
En regard de la th√©orie des types, il s‚Äôagit d‚Äôun constructeur (de type non scalaire)
applicable √† un ensemble de tuples de m√™me type.

ifdef::format_DIAPO[<<<]
Soit a~i~ des identifiants distincts, D~j~ des types et t~k~ des tuples, une relation R
est d√©finie comme suit‚ÄØ:

[.text-center]
[.Math]#R ‚âú ({a~1~:D~1~, ‚Ä¶, a~i~:D~i~, ‚Ä¶, a~n~:D~n~}‚ÄØ; {t~1~, ‚Ä¶, t~k~, ‚Ä¶, t~m~})#

avec

[.text-center]
[.Math]#‚àÄ 1 ‚â§ k ‚â§ card\(R) : def\(R)=def(t~k~)#

o√π

[%unbreakable]
[width=90%, grid=none, frame=none, role=center]
|===
| [.Math]#deg\(R) = n#                          |le degr√© de R
| [.Math]#card\(R) = m#                         |la cardinalit√© de R
| [.Math]#id\(R) = {a~1~, ‚Ä¶, a~i~,‚Ä¶, a~n~}#     |l‚Äôensemble des identifiants d‚Äôattributs de R
| [.Math]#val\(R) = {t~1~, ‚Ä¶, t~k~, ‚Ä¶, t~m~}#   |la valeur de R
| [.Math]#def\(R) = {a~1~:D~1~, ‚Ä¶, a~i~:D~i~, ‚Ä¶, a~n~:D~n~}#     |l‚Äôent√™te de R
| [.Math]#def(R, a~i~) = D~i~#                  |le type de l‚Äôattribut a~i~ de R
|===

ifdef::format_DIAPO[<<<]
.Pr√©dicat et relation
Un pr√©dicat peut √™tre d√©fini de deux fa√ßons et, corolairement, une relation aussi‚ÄØ:

* par √©num√©ration (l‚Äôensemble de tous les √©nonc√©s vrais et eux seuls)‚ÄØ;
* par compr√©hension (la caract√©risation n√©cessaire et suffisante des relations
  entre les variables).

.Observation
Pourquoi autoriser [.Math]#deg\(R) = 0#‚ÄØ?

Le cas [.Math]#deg\(R) = 0# correspond √† deux (valeurs de) relations remarquables‚ÄØ:

* [.Math]#({}‚ÄØ; {})#
* [.Math]#({}‚ÄØ; t~0~)#

Elles sont tr√®s importantes, comme le z√©ro et le un pour les entiers‚ÄØ!

.Exercice
Expliquer pourquoi‚ÄØ!

ifdef::format_DIAPO[<<<]
.D√©notation des constructeurs de types et de valeurs
Il est important, en pratique et du point de vue du g√©nie logiciel, de diff√©rencier
syntaxiquement le constructeur de types du constructeur de valeurs, ce que Tutorial D
ne fait pas de fa√ßon assez explicite, nous semble-t-il.

Attendu la solution retenue par Discipulus (voir section pr√©c√©dente),
les (deux seules) valeurs de relations sans attributs sont repr√©sent√©es par

* [.CodeS]#RELATION [{}‚ÄØ; {}]# et
* [.CodeS]#RELATION [{}‚ÄØ; {TUPLE [{}‚ÄØ; {}]}]#.

Cela ne rappelle-t-il pas quelque chose aux Bourbakistes parmi vous‚ÄØ?

////
TODO 2024-04-01 (LL01) Revoir l‚Äôexplication pr√©c√©dente, elle est vraiment obscure!
////

ifdef::format_DIAPO[<<<]
=== Base
Une base, en tant qu‚Äôobjet de la th√©orie relationnelle, est une ¬´‚ÄØcomposition‚ÄØ¬ª
de relations.
ifdef::format_DIAPO[ ]
En regard de la th√©orie des types, il s‚Äôagit d‚Äôun constructeur (de type non scalaire)
applicable √† un ensemble de relations.

ifdef::format_DIAPO[<<<]
Soit v~i~ des identifiants distincts, D~i~ des types de relation et r~i~ des (valeurs de)
relations, une base (banque) B est d√©finie comme suit‚ÄØ:

[.text-center]
[.Math]#B ‚âú ({v~1~:D~1~, ‚Ä¶, v~i~:D~i~, ‚Ä¶, v~n~:D~n~}‚ÄØ; {r~1~, ‚Ä¶, r~i~, ‚Ä¶, r~n~})#

avec

[.text-center]
[.Math]#‚àÄ 1 ‚â§ i ‚â§ card(B) : def(B, v~i~)=def(r~i~)#

o√π

[%unbreakable]
[width=90%, grid=none, frame=none, role=center]
|===
| [.Math]#deg(B) = n#                                        | degr√© de B
| [.Math]#id(B) = {v~1~, ‚Ä¶, v~i~, ‚Ä¶, v~n~}#                  | ensemble des identifiants de B
| [.Math]#val(B) = {r~1~, ‚Ä¶, r~i~, ‚Ä¶, r~n~}#                 | valeur de B
| [.Math]#def(B) = {v~1~:D~1~, ‚Ä¶, v~i~:D~i~, ‚Ä¶, v~n~:D~n~}#  | ent√™te de B
| [.Math]#def(B, a~i~) = D~i~#                               | type de ai de B
|===

ifdef::format_DIAPO[<<<]
== Op√©rateurs relationnels
L‚Äôalg√®bre relationnelle est souvent pr√©sent√©e √† l‚Äôaide de six op√©rateurs de base‚ÄØ:

ifdef::format_DIAPO[<<<]
* *renommage*, [.Math]#R œÅ a:b#, la relation comprenant tous les tuples form√©s
  √† partir d‚Äôun tuple de [.Math]#R# dont l‚Äôattribut de nom [.Math]#a# est remplac√©
  par un attribut de nom [.Math]#b# de m√™me valeur, et rien d‚Äôautre‚ÄØ;
* *restriction*, [.Math]#R œÉ c#, la relation comprenant tous les tuples de [.Math]#R#
  satisfaisant la condition [.Math]#c#, et rien d‚Äôautre‚ÄØ;
* *projection*, [.Math]#R œÄ x#, la relation comprenant tous les tuples form√©s √† partir
  d‚Äôun tuple de R dont seuls les attributs dont le nom est parmi [.Math]#x# ont √©t√© conserv√©s,
  et rien d‚Äôautre‚ÄØ;
* *jointure*, [.Math]#R ‚ãà S#, la relation comprenant tous les tuples form√©s
  des attributs d‚Äôun tuple de [.Math]#R# et de ceux d‚Äôun tuple de [.Math]#S#
  dont les attributs de m√™me nom sont de m√™me valeur, et rien d‚Äôautre‚ÄØ;
* *union*, [.Math]#R ‚à™ S#, la relation comprenant tous les tuples de [.Math]#R#
  et tous les tuples de [.Math]#S#, et rien d‚Äôautre‚ÄØ;
* *diff√©rence*, [.Math]#R ‚Äì S#, la relation comprenant tous les tuples de [.Math]#R#
  qui ne sont pas dans [.Math]#S#, et rien d‚Äôautre.

ifndef::format_DIAPO[]
.Note sur le renommage
Le statut de l‚Äôop√©rateur de renommage est encore discut√© au sein de la
communaut√© scientifique.

1. Il est possible de se passer de l‚Äôop√©rateur de renommage si on int√®gre une
   structure de catalogue √† la th√©orie relationnelle, puisque le renommage peut
   alors √™tre exprim√© √† l‚Äôaide des autres op√©rateurs relationnels appliqu√©s aux
   variables de relation appropri√©es du catalogue.
2. L‚Äôop√©rateur de renommage d√©coule d‚Äôun principe plus g√©n√©ral, le principe de substitution.
   En ce sens, il n‚Äôappartient pas √† la th√©orie relationnelle en propre, mais √† la
   formalisation de toute alg√®bre.

Toutefois, le prix √† payer afin d‚Äôomettre l‚Äôop√©rateur de renommage est une
complexification de la formalisation de la th√©orie et, corolairement,
des mod√®les qui en d√©coulent et donc des expressions relationnelles en
regard de ceux-ci.
Pour cela, il est usuel de le maintenir dans les op√©rateurs de base.

Ceci n‚Äôemp√™che pas pour autant l‚Äôabandon du principe plus g√©n√©ral.
Une syntaxe sp√©cifique, semblable √† celle fr√©quemment utilis√©e en math√©matique
pour le m√™me usage ([.Math]#soit x = exp‚ÄØ: f(x)#), peut √™tre d√©finie.
Cet op√©rateur est par exemple fr√©quemment pr√©sent dans les langages relationnels
(par exemple, en SQL, [.SQL]#WITH ‚Ä¶#).

.Note sur la projection
Le langage Tutorial D d√©note la projection par la juxtaposition d‚Äôune
(d√©notation de) relation et d‚Äôune (d√©notation de) liste d‚Äôattributs‚ÄØ:

[.TutorialD]#R {a~1~,‚Ä¶, a~n~}# ‚â° [.Math]#R œÄ {a~1~,‚Ä¶, a~n~}#

Cet usage peut √™tre vu comme analogue √† la d√©notation de la multiplication
en arithm√©tique par juxtaposition des deux op√©randes.
Par souci de lisibilit√©, nous √©viterons le plus souvent d‚Äôutiliser ce raccourci notionnel.

.Note sur le produit cart√©sien
Dans ses premi√®res publications, Codd utilisait un ensemble d‚Äôop√©rateurs de base
comprenant le produit cart√©sien plut√¥t que la jointure.
Sachant que le produit cart√©sien est un cas particulier de la jointure et
que la jointure peut √™tre exprim√©e en combinant le produit cart√©sien et
la restriction, les deux ensembles sont donc √©quivalents.
Nous pr√©f√©rons la version pr√©sent√©e ici pour des raisons que nous exposerons bient√¥t.

.Note sur l‚Äôalg√®bre minimale _A_
On peut r√©duire l‚Äôensemble des op√©rateurs de base (c‚Äôest-√†-dire le noyau minimal)
aux seuls op√©rateurs suivants : ‚¶âNAND‚¶ä et ‚¶âREMOVE‚¶ä.
La d√©monstration en est faite par Date et Darwen dans le 3^e^ manifeste.

.Plan de la section
Les prochaines sous-sections pr√©sentent la d√©finition formelle des op√©rateurs de base (3.1),
puis la construction, √† partir de ceux-ci, d‚Äôop√©rateurs usuels (3.2), sp√©cialis√©s (3.3)
et de regroupement (3.4).

.Note de LL
Les prochaines sections pr√©sentent un aper√ßu de la mise en correspondance entre
les langages proprement relationnels et SQL, le lecteur trouvera un traitement
plus complet dans [5].
Une confusion certaine est encore manifeste dans la notation des langages relationnels.
La notation de l‚Äôalg√®bre relationnelle est fluctuante selon les auteurs
(ainsi Elmasri, Ullman, Date et Codd utilisent chacun des notations diff√©rentes).
Il en est de m√™me des langages relationnels, tels que
Discipulus
(langage en cours de d√©finition au sein du groupe ŒúŒ∑œÑŒπœÇ ‚Äì ici compos√© en
[.Discipulus]#STIX Two Text de couleur ocre#) et
Tutorial D
(langage d√©fini par Date, mais toujours en √©volution ‚Äì ici compos√© en
[.TutorialD]#Courier de couleur verte#).
Quant √† SQL
(ici compos√© en [.SQL]#Droid Sans Mono de couleur pourpre#),
nous nous r√©f√©rons √† la syntaxe prescrite par la norme ISO/IEC‚ÄØ9075:2016
(qu‚Äôaucun SGBD ne propose sans variation dialectale plus ou moins importante).
endif::format_DIAPO[]

ifdef::format_DIAPO[<<<]
=== Op√©rateurs de base
D√©finition relativement √† la th√©orie des ensembles et √† la repr√©sentation pr√©c√©dente
(au mod√®le, √† la structure).

// √Ä d√©velopperLes √©quivalences sont donn√©es‚Ä¶

ifdef::format_DIAPO[<<<]
==== Renommage
[%unbreakable]
--
[%hardbreaks]
Soit [.Math]#R# une relation,
soit [.Math]#a# et [.Math]#b# deux identifiants :
[.Discipulus]#R œÅ a:b# ‚â°
[.TutorialD]#R RENAME {a AS b}# ‚â°
[.SQL]#select a~1~, ‚Ä¶, a as b, ‚Ä¶, a~n~ from R# ‚â°
[.Math]#ANTE a ‚àà id\(R) ‚ãÄ b ‚àâ id\(R)‚ÄØ:#
[.Math]#¬†¬†SOIT E := def(R,a) ; Z := def\(R) - {a:E} ‚à™ {b:E}‚ÄØ:#
[.Math]#¬†¬†¬†¬†(Z ; {(Z ; val(t) - {(a,val(t,a))} ‚à™ {(b,val(t,a))}) | t ‚àà val\(R)})#
--

.Corolaires
* [.Math]#card\(R) = card(R œÅ a:b)#
* [.Math]#‚àÄ t ‚àà val\(R) : (Z‚ÄØ; val(t) - {(a,val(t,a))} ‚à™ {(b,val(t,a)) ‚àà R œÅ a:b#
* [.Math]#a ‚àâ id(R œÅ a:b) ‚ãÄ  b ‚àà id(R œÅ a:b)#
* [.Math]#R = ((R œÅ a:b) œÅ b:a)#

ifdef::format_DIAPO[<<<]
==== Projection
[%unbreakable]
--
[%hardbreaks]
Soit [.Math]#w# une expression ayant pour valeur une liste d‚Äôidentifiants d‚Äôattribut [.Math]#{w~0~,‚Ä¶, w~n~}# :
[.Discipulus]#R œÄ w# ‚â°
[.TutorialD]#R {w~0~, ‚Ä¶, w~n~}# ‚â°
[.SQL]#select w~1~, ‚Ä¶, w~n~ from R# ‚â°
[.Math]#ANTE w ‚äÜ id\(R) :#
[.Math]#¬†¬†SOIT Z := {a:D | a ‚àà id \(R) ‚ãÄ a ‚àà w} :#
[.Math]#¬†¬†¬†¬†(Z‚ÄØ; {(Z‚ÄØ; {(a,v) | (a,v) ‚àà val(t) ‚ãÄ a ‚àà w}) | t ‚àà val\(R)})#
--

.Remarque
* En Tutorial D et en SQL, la liste doit √™tre explicite.

ifdef::format_DIAPO[<<<]
==== Jointure
[%unbreakable]
--
[%hardbreaks]
Soit [.Math]#R# et [.Math]#S# deux relations :
[.Discipulus]#R ‚ãà S# ‚â°
[.TutorialD]#R JOIN S# ‚â°
[.SQL]#select * from R natural join S# ‚â°
[.Math]#SOIT X := id\(R) ‚à© id(S) :#
[.Math]#¬†¬†ANTE ‚àÄ a ‚àà X : a:D ‚àà def\(R) ‚ãÄ a:D ‚àà def(S) :#
[.Math]#¬†¬†¬†¬†SOIT Z := def\(R) ‚à™ def(S) :#
[.Math]#¬†¬†¬†¬†¬†¬†(Z‚ÄØ; {(Z‚ÄØ; val(t1) ‚à™ val(t2)) |#
[.Math]#¬†¬†¬†¬†¬†¬†¬†¬†t1‚ààval\(R) ‚ãÄ t2‚ààval(S) ‚ãÄ (‚àÄ a‚ààX‚ÄØ: (a,v)‚ààval(t1) ‚ãÄ (a,v)‚ààval(t2))})#
--

ifndef::format_DIAPO[]
.Remarque
* La jointure naturelle n‚Äôest pas commutative en SQL en raison de l‚Äôordonnancement
  des attributs dans un tuple, puisque le tuple y est d√©fini comme une liste ordonn√©e
  d‚Äôattributs et non comme un ensemble d‚Äôattributs.
endif::format_DIAPO[]

ifdef::format_DIAPO[<<<]
==== Restriction
[%unbreakable]
--
[%hardbreaks]
Soit [.Math]#R# une relation,
soit [.Math]#c#, une condition (expression bool√©enne),
soit [.Math]#id(c)#, l‚Äôensemble des identifiants d‚Äôattribut utilis√©s par [.Math]#c# :
[.Discipulus]#R œÉ c# ‚â°
[.TutorialD]#R WHERE c# ‚â°
[.SQL]#select * from R where c# ‚â°
[.Math]#ANTE id(c) ‚äÜ id\(R) :#
[.Math]#¬†¬†(def\(R)‚ÄØ; {t | t ‚àà val\(R) ‚ãÄ c(t)})#
--

ifdef::format_DIAPO[<<<]
==== Union
[%unbreakable]
--
[%hardbreaks]
Soit [.Math]#R# et [.Math]#S# deux relations :
[.Discipulus]#R ‚à™ S# ‚â° +
[.TutorialD]#R UNION S# ‚â° +
[.SQL]#select * from R union select * from S# ‚â°
[.Math]#ANTE def\(R) = def(S) :#
[.Math]#¬†¬†(def\(R)‚ÄØ; val\(R) ‚à™ val(S))#

.Remarque
* L‚Äôant√©c√©dent doit √™tre am√©nag√© en cas de relaxation de la compatibilit√©.
--

ifdef::format_DIAPO[<<<]
==== Diff√©rence
[%unbreakable]
--
[%hardbreaks]
Soit [.Math]#R# et [.Math]#S# deux relations :
[.Discipulus]#R ‚àí S# ‚â°
[.TutorialD]#R MINUS S# ‚â°
[.SQL]#select * from R except select * from S# ‚â° +
[.Math]#ANTE def\(R) = def(S) :#
[.Math]#¬†¬†(def\(R)‚ÄØ; val\(R) ‚àí val(S))#

.Remarque
* L‚Äôant√©c√©dent doit √™tre am√©nag√© en cas de relaxation de la compatibilit√©.
--

ifdef::format_DIAPO[<<<]
=== Op√©rateurs usuels

*_!!! √Ä retranscrire depuis le document d‚ÄôAkademia !!!_*

=== Op√©rateurs sp√©cialis√©s

*_!!! √Ä retranscrire depuis le document d‚ÄôAkademia !!!_*

=== Op√©rateurs de regroupement

*_!!! √Ä retranscrire depuis le document d‚ÄôAkademia !!!_*

<<<
[conclusion]
== Conclusion

Merci aux membres de CoLOED, CoFELI et ŒúŒ∑œÑŒπœÇ üòÄ

<<<
[references]
== R√©f√©rences
PG::
`[fr]` https://docs.postgresql.fr/16/index.html (2024-04-01) +
`[en]` https://www.postgresql.org/docs/16/index.html (2024-04-01)

<<<
[glosssary]
== Glossaire

----
Sources consult√©es en juin et juillet 2023

* Antidote : Antidote Antidote 11 v4.2 (2023), voir https://www.antidote.info
* Larousse : https://www.larousse.fr/dictionnaires/francais
* Le Robert : https://dictionnaire.lerobert.com
* Wikip√©dia : https://fr.wikipedia.org/wiki
----

include::{rep_Scriptorum}/doc/_glo/ACID.adoc[]

ifdef::format_DIAPO[include::{rep_format}/DIAPO_en-pied.adoc[]]
ifndef::format_DIAPO[include::{rep_format}/{format_effectif}_en-pied.adoc[]]
