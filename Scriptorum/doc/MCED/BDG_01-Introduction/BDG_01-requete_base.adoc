:sigle: Base de donn√©es de graphes 
:titre: Mod√®les de graphe
:sous_titre: 
:organisation: CoFELI
:entrepot: CoFELI
:!branche:
:description: {titre} ‚Äî {sous_titre}
:outline-title: Œ± ‚Äî {description}
:keywords: r√©daction technique, documentation technique, Convention matawine
:revnumber: 1.0.0.a
:revdate: 2024-01-26
:version-label: document de travail, ne pas citer
:author: Christina Khnaisser
:email: Christina.Khnaisser@usherbrooke.ca
:stem: latexmath

// Contexte de support du document
include::../../../../../rep_CoLOED_AsciiDoc.adoc[]

// Format du document
include::{rep_format}/RAPPORT_en-tete.adoc[]

ifdef::diapo[<<<]
toc::[]
ifdef::diapo[<<<]
== Introduction

Cete section pr√©sente une surval des concepts de construction d'une requ√™te sur
un mod√®le de graphe. Nous allons utilis√© le language Cypher pour faire des exemples.

ifdef::diapo[<<<]
=== Motifs
* Motif
* Expression r√©guli√®re

ifndef::diapo[]
Une requ√™te dans un mod√®le de graph est bas√© sur le concept de motif (_pattern_)
L'id√©e de base est de trouver les donn√©es qui correspondent au motif sp√©cifi√©.

Un motif est une expression r√©guli√®re calculable sur les √©tiquettes.
endif::diapo[]

ifdef::diapo[<<<]
=== Requ√™te de base 

==== D√©finition
* Information sur les entit√©s
* Information sur les associations

ifndef::diapo[]
Une requ√™te de base permet de trouver des informations sur les entit√©s ou les associations existant (ou pas) dans un graphe. 
Avec un graphe de propri√©t√©s, nous ponvons pr√©ciser l'entit√© ou l'association d'int√©r√™t
en utilisant les √©tiquettes (ex. :Etudiant, :Professeur, :Inscription). 
De plus, gra√ße au propri√©t√© nous pouvons restreindre notre
recherche avec des conditions bool√©enes (ex. age > 60).

Vu l'absence de sch√©ma, une recherche avec toutes √©tiquettes est possible. 
S'il y a aucune entit√©, association ou propri√©t√© qui corresponds √† l'expression fournie, 
le r√©sultat sera vide.
Ce qui diff√®re des autres language de d√©finition de requ√™tes comme SQL.
endif::diapo[]

ifdef::diapo[<<<]
==== Cypher
* Requ√™te sur une entit√©  
[source,cypher]
----
match (n:Expert)
return n
----
* Requ√™te sur une entit√© avec s√©lection d'une propri√©t√©
[source,cypher]
----
match (n:Expert)
return n.naissance, n.salaire
----
ifdef::diapo[<<<]
* Requ√™te sur une entit√© avec restriction
[source,cypher]
----
match (n:Expert)
where n.salaire > 2000
return m.nom, n.naissance
----
* Requ√™te sur une association connu
[source,cypher]
----
match (n:Novice)-[r:connaitre]->(e:Expert)
return n.nom, e.nom
----
* Requ√™te sur une association inconnu
[source,cypher]
----
match (n:Novice)-[r]->(e:Expert)
return n.nom, type(r), e.nom
----
ifdef::diapo[<<<]
* Requ√™te sur une association avec restriction
[source,cypher]
----
match (n:Novice)-[r:connaitre]->(e:Expert)
where r.depuis > 2000
return n.nom, e.nom
----

ifndef::diapo[]
Avec Cypher les parenth√®ses `()` d√©signe une entit√© (_node_),  
,les crochets `[]` d√©signe une association (_relationship_)
et les accolades `{}` d√©signe une propri√©t√©.

Une requ√™te poss√®de minimalement deux instructions : 

* `MATCH` d√©signe une projection sur le graphe 
* `RETURN` d√©signe une selection sur les objets collecter 
endif::diapo[]

ifdef::diapo[<<<]
=== Requ√™te de chemin r√©gulier

==== D√©finition
* Paires d'entit√©s li√©es
* S√©quence des √©tiquettes d'association qui correspond √† motif

ifndef::diapo[]
Une requ√™te de chemin r√©gulier (_Regular path queries [RQP]_) consiste √† obtenir toutes les paires d'entit√©s li√©s par au moins un chemin o√π la s√©quence des √©tiquettes des association le long du chemin forme un mot dans le langage d'une expression r√©guli√®re donn√©e sur les √©tiquettes des associations du graphe.

Une paire d'entit√© fait partie de la r√©ponse d‚Äôune requ√™te 
ssi les entit√©s sont li√©es dans le graphe par un chemin conforme au motif.

Une requ√™te de chemin r√©gulier s'exprime comme suite :
endif::diapo[]

* si ùëé ‚àà ‚Ñí      alors latexmath:[ùëé ‚àà ùëÖùëÑùëÉ]
* si ùëí ‚àà ùëÖùëÑùëÉ    alors latexmath:[(ùëí)^- ‚àà ùëÖùëÑùëÉ] (inverse) 
* si ùëí,ùëì ‚àà ùëÖùëÑùëÉ  alors latexmath:[(ùëí)/(ùëì) ‚àà ùëÖùëÑùëÉ] (s√©quence)
* si ùëí,ùëì ‚àà ùëÖùëÑùëÉ  alors latexmath:[(e)+(f) ‚àà ùëÖùëÑùëÉ] (union)
* si ùëí ‚àà ùëÖùëÑùëÉ    alors latexmath:[(ùëí)^+ ‚àà ùëÖùëÑùëÉ] (fermeture transitive)

ifdef::diapo[<<<]
==== Cypher
* Requ√™te avec une inverse 
[source,cypher]
----
match (n:Expert)<-[r:connaitre]-(e)
return n.nom as expert, labels(e)
----
* Requ√™te avec une s√©quence d√©termin√©
[source,cypher]
----
match (n)-[r1:connaitre]->(x)-[r2:travaillerPour]->(y)-[r3:connaitre]->(e)
return n, e
----
ifdef::diapo[<<<]
* Requ√™te avec une s√©quence avec distance entre 1 et 5
[source,cypher]
----
match (n:Novice)-[r:connaitre]-{1,5}(e)
return n, e
----
* Requ√™te avec une union
[source,cypher]
----
match (n:Novice)
where n.salaire = 1000
return id(n)
union
match (n:Apprenti)
where n.salaire = 1000
return id(n)
----
ifdef::diapo[<<<]
* Trouver la listes des connaissances directes et indirectes de Mathieu.
[source,cypher]
----
match (jason) 
where jason.nom = 'Mathieu'
match (jason)-[:connaitre*]->(connaissance)
return collect(distinct id(connaissance))
----

ifdef::diapo[<<<]
[NOTE]
====
Op√©rateur pr√©d√©fini dans Neo4j :

* `id` : obtenir l'identit√© d'une entit√© 
* `label` : obtenir l'√©tiquette d'une entit√©
* `type`  : obtenir l'√©tiquette d'une association
====

ifdef::diapo[<<<]
=== Requ√™te d'aggr√©gation

==== D√©finition
* D√©compte
* Somme
* Minimum
* Maximun
* List
* ... et d'autres fonctions statistiques.

ifdef::diapo[<<<]
==== Cypher
* Requ√™te avec d√©compte
----
match (n:Expert)
return count(n) as nbExpert
----
* Requ√™te avec somme
----
match (n:Expert)
return sum(n.salaire) as budget
----
ifdef::diapo[<<<]
* Requ√™te avec minimum
----
match (n:Expert)
return min(n.salaire) as salaireMin
----
* Requ√™te avec maximum
----
match (n:Expert)
return max(n.salaire) as salaireMax
----
* Requ√™te avec liste 
----
match (n:Expert)
return collect(n.salaire) as SalaireList
----

ifdef::diapo[<<<]
[bibliography]
== R√©f√©rences

Bonifati, Angela, George Fletcher, Hannes Voigt, Nikolay. Yakovets, et H. V. Jagadish. 
Querying Graphs. Chapitre 3. Morgan & Claypool, 2018. +
https://ieeexplore.ieee.org/servlet/opac?bknumber=8481009.

Neo4j - Cypher Manuel 
https://neo4j.com/docs/cypher-manual/current/functions/

//Linked Data Benchmark Council (LDBC) + https://ldbcouncil.org

// ====================================== FIN =================================
include::{rep_format}/RAPPORT_en-pied.adoc[]